# 导读

偶然遇到了这样的一段代码。

```
    const add = (m,n) => m+n;
    add(010,020)
```

这段代码实质就是问你**010+020**的答案，

我当时看的时候也没细想，很自然的就觉得答案是30，但是后来敲了一下代码发现，答案竟然是24！

这引起了我深深的好奇，为此我特意的翻阅了一些关于JavaScript中数字类型的一些机制，特此在这里分享出来。


<!--more-->


在开始之前，我需要和读者们在数字存储上达成这样一个共识。

**计算机不可能无限制的存储任意长度的数字**。

这很容易理解，如果计算机存储数字不加以限制的话，数字是没有最大值的，用户可以轻易的输入无限制长度的数字。也就是说用户可以轻松的达到计算机的存储极限，如果对这样的数字再进行运算，emmmm，想想就觉得很美好~

不行的小伙伴把这串数字复制到console里看看

```
999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999990
```

看看结果是不是**Infinity**。

# 存储机制

为什么会是Infinity呢？

因为在JavaScript中遵从了[IEEE754](https://en.wikipedia.org/wiki/IEEE_floating_point)规范，数字的存储采用的是64位双精度浮点数形式,也就是说JavaScript最多表达64位字节的数字。。

首先简单一下介绍数据存储单位。

在计算机中，最小的存储单位叫做bit，中文叫做**位**

大点儿的呢，叫做Byte，中文叫做**比特/字节**，1Byte = 8bit;

再依次向上就是咱们熟悉到KB,MB,G,T了。

解释一下**64位双精度浮点数**这个关键词

* 64位双精度

与之对应的是32位单精度,关于位数刚才已经说过了，一位就代表计算机中最小的存储单位。64位代表**任何一个数字在内存中占有64bit的存储空间**，
 
双精度的概念是针对于单精度而言的。

单精度存储占用4个字节，因此存储范围小(3.4*10e38)，精度低，但是计算机执行速度快，在其他语言中被称作`float`。

32位= 1(标志位) +  7(指数位) + 23(有效位)

双精度存储占用8个字节，因此存储范围大(1.8*10e308)，精度高，但是计算机执行速度稍慢，在其他语言中被称作`double`。
 
64位 = 1(标志位) +  11(指数位) + 52(有效位)


* 浮点数

浮点数是相对于定点数而言单，定点定的就是小数点，输入多少就是多少

定点数的缺点是不够灵活，固定的小数点位置决定了固定位数的整数部分和小数部分，不利于同时表达特别大的数或者特别小的数。

因此在计算机中，一般采用浮点数进行存储。

以**123456.789**这个数字为例。

使用定点数表示仍然是**123456.789**

使用浮点数表示则是

```
    1.23456789*10e5
    // 1.23456789乘以10的5次方
```

1.23456789被称为**尾数(也叫做有效数字)**

10被称为**基数**

5被称为**指数**

JavaScript数字存储格式

| 符号位 | 指数  |  尾数  |  基数  |
| :-:   |:-:   |:-:   |:-:   |
| 1(0正1负)   | 11(-1024至1023) | 52  | 10 |


换算成数字的话，他所能表达的最大值与最小值分别是

| 符号位 | 指数  |  尾数  |  基数  |
| :-:   |:-:   |:-:   |:-:   |
| 1   | 000 0000 0001 | 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000  | 2 |
| 0   | 111 1111 1110 | 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111  | 2 |

在计算机中，一个数字的有效范围有`指数`决定，也就是说，在JavaScript中，最大的值是2的1024次方-2，超过这个极限就是`Infinity`.

换算成十进制的话，JavaScript可以表达的最大值是1.7976931348623157e+308。

而这正好也是JavaScript中Number.MAX_VALUE的值。

# 010？

回到最初的问题，问什么010+020==24？

原因很简单，在JavaScript数字存储机制中，有一种很特殊的情况，**任何以0或0X开始的数字都以8进制解析**。

```javascript
    010  ======= 8
 +  020  ======= 16  +
 -------------------
    030          24
```

# 精度丢失的原因

上文提到了JavaScript中最大数字范围是1.8e308

但是JavaScript中数字类型的尾数(有效数字)的最大长度为52位，超过52位之后的数字都会被进行0舍1入的处理。

所以在JavaScript中精度的极限就是**Math.pow(2,-53)**与**Math.pow(2,53)**。

是53位的原因是加上了符号位。

超过这个范围之后，就会因为0舍1入导致一些精度丢失问题。

在JavaScript中，有**Number.MAX_SAFE_INTEGER(9007199254740991)**与**MIN_SAFE_INTEGER(-9007199254740991)**来表达安全整数的范围

可以看看

> Number.MAX_SAFE_INTEGER 是不是和Math.pow(2,53)相等

> Number.MIN_SAFE_INTEGER 是不是和Math.pow(2,-53)相等


为了证明这个情况的真实性，可以验证以下代码。

```
var a = 9007199254740991;
a+1;        // => 9007199254740992 
a+2;        // => 9007199254740992 
```

# 大数相加

上文提到了在JavaScript中只有处于Math.pow(2,-53)与Math.pow(2,53)之间的数字才是安全的，不回丢失精度的。

那么在日常业务逻辑中（类似与淘宝的订单号数字），如果需要处理的数字大于Math.pow(2,53)怎么办呢？

超过了安全范围，计算后因为精度丢失导致了结果不准确，导致订单号错乱，然后快递寄错了...手动滑稽～

解决这个问题也不难。

先说一下处理的思路。

1. 将数字转换为数组
2. 前位补0到二者长度一致
3. 遍历二者
4. 当前项相加，判断前一项和是否有进位，有则加上1
5. 如果结果大于10，则将个位数推进结果数组，否则将和推入结果数组
6. 遍历完成
7. 数组转字符串转数字

代码在这里。

```javascript
function add (a,b){ 
        var a = String(a).split(''),
            b = String(b).split(''),
            // 结果数组
            result = [],
            // 相加和进位
            carry = 0,
            // 相加和数值
            current = '',
            // 长度差
            distance = a.length - b.length, 
            // 较大数字的长度
            len = distance > 0 ? a.length : b.length; 
            // 位数补全
            if(distance > 0) {
                for(let i = 0;i < distance;i++) {
                    b.unshift('0')
                }
            }
            else {
                for(let i = 0 ; i < -distance;i++) {
                    a.unshift('0')
                }
            }    
            for(let j = len - 1; j>= 0; j--) {
                current = (+a[j]) + (+b[j]) + carry ;
                // console.log(a[j],b[j],current,carry)
                // console.log()
                if(current > 10) { 
                    result.push((current+'')[1]);
                    carry = 1;
                }
                else {
                    result.push(current);
                    carry = 0;
                }
            }
            result = result.reverse().join(''); 
            return result;
    }   
```

在线代码看[这儿](https://runjs.cn/code/qcxmgit7)

# 小数相加

上面我们解决了大数相加的问题，但其实小数相加的问题也是存在的。

可能很多人都看过这段代码。

```
    0.1 + 0.2 ===  0.3 0000 0000 0000 0004
```

来借助我们上文谈到的64位双精度浮点数存储机制，我们把他转化成在计算机中存储的数据。

首先把10进制转化为2进值

```
    0.1 === 0.00 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 01 // 52位
    
    0.2 === 0.00 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 11 // 52位
    
```

相加后的值为

```
    0.01001100110011001100110011001100110011001100110011001100 
```

转换为10进值后的值即为**0.30000000000000004**

参考他们在浮点数形式的各种参数。

| 数字 | 符号位 | 指数  |  尾数  |  基数  |
| :-: | :-: |:-:   |:-:   |:-:   |
| 0.1 | 0(正数)   | 00000000100(-4) | 1.100110011001100110011001100110011001100110011001  | 10 |
| 0.2 | 0(正数)   | 00000000011(-3) | 1.100110011001100110011001100110011001100110011001  | 10 |


如何解决呢？

很简单，将小数转化为整数，然后再转化为小数即可。


# 总结

1. JavaScript数字机制是基于IEEE754标准，采取64位双精度浮点数的存储机制
2. JavaScript可存储的范围在Number.MIN_VALUE和Number.MAX_VALUE
3. JavaScript安全存储范围在Number.MIN_SAFE_INTEGER和Number.MAX_SAFE_INTEGER之间
4. 精度丢失的原因是尾数只能存储52位，超过的位数都被0舍1入了。 