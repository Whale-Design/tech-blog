
# 导读

这篇文章讨论的是关于JavaScript的单线程机制，以及由于单线程机制所衍生的执行队列的问题。

仍然是以一段代码开头。

```javascript
const log = str => console.log(str); 
setTimeout(log,0,2);
new Promise(()=>{
	log(3)
})
log(1); 
```

首先答案肯定不是`1,2,3`，要是的话，我也没必要拿出来说。

具体的答案等到看完这篇文章，你自然就知道了。

我想要通过这段代码说明的是JavaScript线程，队列与event loop相关的机制。

<!-- more -->

首先我们得知道，JavaScript是处于浏览器环境的，而在浏览器中由很多的操作是需要时间去处理的，例如IO操作，HTTP请求，DOM操作等。

它并不是JavaScript解析完了这段代码就可以立即一行一行执行的。

例如这段代码。

```javascript
    document.body.onclick = function(){
        alert(1)
    }
```
它不是页面一上来就`alert`,而是在body被点击的时候`alert`。

它不是解析即执行，它需要一段不定的等待时间，在将来的某一刻触发！

但是浏览器不能一直处于等待的状态，例如某一行代码发送了一个http请求，解析器就一直等待请求的结果，直到有了结果之后，才开始执行下一句代码，这样的浏览器会一直处于假死状态，用户无法进行任何操作，这样绝对是不行的。

因此必须有一种机制来解决**解析时无法立即得到结果，而在将来的不确定的某一刻时间会得到**这种问题。

这种机制叫做**异步队列**。

在谈到队列之前，需要先了解以下进程与线程的概念。

 
# 进程

所有的软件本质上都是程序，计算机执行这段程序，使用计算机的资源，达成程序预期的目的。

那么计算机是如何执行这段程序的呢？

我们得知道程序本身是没有生命的，它只是一堆死的，静态的字符串。

只有当计算机开辟了**进程**，进程分配CPU，内存，硬盘等资源，将这段字符串翻译成计算机可以识别的01码，然后通过CPU的计算能力，搭配计算机中的其他资源，执行了这段字符串之后，程序才真正的开始发挥它的功能，完成程序功能。

这个进程其实就是一个可以分配计算机各种资源的实体区域，他是可以分配计算机资源的最小单位。

它包括用来存储执行代码的**文本区域**，用来存储数据的**数据区域**以及用来执行代码的**堆栈**。

每一个程序都最少有一个进程，有的程序会有多个进程。

当软件被打开时，计算机会开辟一个进程来运行程序，当软件被关闭时，计算机终止掉运行这个程序的这个进程。

在windows中，`Ctrl+Alt+Delete`呼唤出任务管理器，第一个tab项目就是进程。

进程有五种状态，对应着进程的整个生命周期。

|  状态  | 含义  |
| :-:  |  :-:  |
| 新建态  | 刚创建的进程，操作系统还没有开始执行这个进程 |
| 就绪态  | 进程已经做好准备，可以开始执行 |
| 运行态  | 进程正在执行，如果计算机只有一个处理器，那么一次最多只有一个进程处于运行态 |
| 阻塞态  | 进程在某一些操作完成之前，无法继续执行，例如IO操作 |
| 退出态  | 进程结束运行  |

以我们最为熟悉的chrome为例。

以chrome为例，chrome浏览器自身占有一个父进程，打开一个chrome插件会占有一个子进程，新开一个tab页也会占有一个子进程。

![进程](/img/异步编程/progress.png)

可以看到chrome浏览器占有了十来个进程。

那么chrome占有了这么多的进程，那么为什么还说JavaScript是单线程的呢？

# 线程

JavaScript是一门单线程的语言，指的是JavaScript引擎只使用一个线程，与之类似的是java，python等多线程语言。

那么什么是线程呢？

javaScript线程就是用来解析JavaScript代码，调用计算机的各种资源(CPU的计算资源，显卡的渲染资源，网卡的通信资源)完成/实现/执行这段代码。

按照线程与进程的定义来说，貌似他们没有什么区别，那为什么还有二者之分呢？

原因在这里

进程类比于一个大号的工厂，拥有很多的作坊，可以接受巨量的原材料，然后调度大量的计算机资源，将原材料加工，输入成熟的产品，一般只接，只做大项目，

线程类比于一个小号的作坊，作坊主自己做工人，如果有一些活儿自己做不了的话，可以找一个厂里其他的作坊帮帮忙，接受的原材料少，调度的计算机资源也小，但是也能输入成熟的产品，只能做小活儿。

他们二者区别是进程是`宰牛刀`，线程是`杀鸡刀`，杀鸡焉用牛刀，合理分配计算机资源，避免不必要的浪费，这是设计出二者的原因。

一个进程最少会有一个线程，任何浏览器的JavaScript引擎都是单线程的。
 
那JavaScript为什么是单线程的呢？

这个原因很好理解，假设JavaScript有A，B两个线程。

A线程执行:

```
    document.getElementById('root').style.background = 'red';
```

B线程执行:

```
    document.body.removeChild(document.getElementById('root))
```

A线程需要操作root元素，而B线程删除了root元素，这样两个线程就产生了冲突，浏览器就爆栈，页面就卡死了。

所以为了避免产生这种冲突，JavaScript必须是单线程！

用一段很简单的代码来证明JavaScript的单线程机制。

```javascript
    alert(1);
    document.body.style.backgroundColor = 'red';
```

只要不关闭掉alert的弹窗，页面是不会变红的，因为JavaScript线程在alert弹窗关闭前是阻塞的状态。

示例代码在[这儿](https://runjs.cn/code/xswpdlel)

JavaScript是单线程的，但是并不是说一个页面就仅仅只有一个线程，浏览器除了JavaScript线程之外，还保持了一些其他的常驻线程来完成一些其他的工作。



1. GUI渲染线程
2. 浏览器DOM事件触发线程
3. HTTP请求线程
4. event loop处理线程

> 如果用户安装了插件，浏览器还会为插件分配新的进程与线程，以支持该插件实现功能。


# 执行机制(简)

在浏览器中，JavaScript引擎占据主线程，用来执行代码。

他就像是一个小盒子，把`alert(1)`放到这个小盒子里，JavaScript引擎就会调用运行环境(runtime)的API，在浏览器中出现一个alert弹窗，而在node中则会报错`ReferenceError: alert is not defined`

来看这样的一段代码。

```javascript
    const log = str => console.log(str); 
    setTimeout(log,0,2);
    new Promise(()=>{
        log(3)
    })
    log(1); 
```

这段代码的执行机制是这样的。

JavaScript引擎执行代码，会将所有的代码按照同步与异步划分为两类。

将同步的代码直接排队等待执行

将异步代码则推送至任务队列，等待异步代码执行完毕之后，由**event loop**机制推送至主线程中排队执行。

![简单的js执行机制](/img/线程与队列/简单的js执行机制.png)

整个执行的过程非常简单，你可能唯一存在的疑惑是JavaScript引擎是怎么将代码区分为同步与异步的？

从机制的角度看，任何无法立即得到结果的代码，都隶属于异步，例如Promise,async,await,Generator等机制。

在线程的角度看，异步的本质就是**和JavaScript引擎不处于同一个线程的代码**，例如dom事件的** DOM Binding线程**，ajax的**http线程**，settimeout的**timer线程**。

JavaScript线程只能管自己的一亩三分地，其他线程他也管不了，所以只能将代码推入任务队列中。

接下来看看任务队列机制。

# 任务队列

任务队列实际上是**非JavaScript线程返回的通知的集合**，在ecma新增了异步操作之后，又分为了宏观任务与微观任务。

任务队列有多个，每一种任务源具有一个任务队列。

他是按照任务源区分的，本质是按照线程区分的。

例如定时器(setTimeout,setInterval)属于timer线程，具有自己的任务队列；dom事件，http请求，promise同理。

![任务队列](/img/线程与队列/任务队列.png)

上图用JavaScript线程，web api，任务队列们三个部分来说明任务队列与JavaScript主线程之间的关系。

> JavaScript主线程是JavaScript引擎所处线程，用来执行代码

> web api指浏览器提供的其他线程状态变化的api接口。例如http请求的`onreadystatechange`，dom event的`onclick`，timer线程的`setTimeout`等。

> JavaScript所处理的任务队列们，同一个任务源(同一个线程)具有同一个任务队列。

整个流程是这样的。

1. JavaScript线程执行到**settimeout**,**ajax**等代码时，会交付给`web api`去处理相应的任务，自身则继续执行主线程中的代码，直到主线程为空。

2.  `web api`在异步线程执行过程中，状态变化时，将各种状态变化的监听函数推入到与之同源的任务队列，直到异步线程完成并关闭。

3.  JavaScript线程按照顺序获取任务队列中的代码执行，队列之间顺序执行(队列之间的顺序与环境有关)，同一个队列中的任务依次执行，直到任务队列为空。


即便是后续将任务队列分为了`宏观任务队列`与`微观任务队列`，也只是队列内部执行顺序的微小调整，并不影响整个事件轮寻。



## 宏观任务队列

宏观任务队列又被叫做`macrotask`，也被叫做`job`，意为它是浏览器的一个工作。

宏观任务队列指非JavaScript线程的其他线程状态变化时的监听函数的任务队列，例如http请求，dom事件等。

宏观任务队列的开销较大，因此他的执行优先级是小于微观任务队列的，在执行完成之后，浏览器是可以重新渲染的。

宏观任务队列可以有多个。

## 微观任务队列

微观任务队列被叫做`microtask`，也被叫做`task`，意为他是浏览器的一个任务

在ES6中，新增了`Promise`来进行异步操作。在node中还有`progress.nextTick`，包括Object.observer, MutationObserver等，他们都属于微观任务队列。

它指的是更新程序状态的一些小任务，比如说promise的状态变化等。

微观任务队列的开销较小，执行优先级较高，且浏览器不会重新渲染。

微观任务队列有且仅有一个。

我们来测试一下二者的优先级问题。

```javascript
    const log = str => console.log(str); 
    setTimeout(log,0,2);
    new Promise(()=>{
        log(3)
    })
    log(1); 
```

promise任务隶属于微观任务，`setTimeout`隶属于宏观任务，执行结果为`2,1`，据此可以判断出微观任务的优先级是高于宏观任务的。

在有了微观任务队列之后，代码的执行机制有了一些微小的区别。

![任务队列](/img/线程与队列/任务队列（全）.png)]

只有当微观任务执行完成之后，才会执行宏观任务队列中的任务。

如果看到这儿了，我觉得文章开头的代码应该已经可以很清晰的知道他的执行流程了。

![进程与队列示例代码](/img/线程与队列/进程与队列示例代码.jpg)

# event loop

说到`event loop`就绕不过这张图。

![event loop](/img/线程与队列/eventLoop.png)

简单来说，`event loop`就是**JavaScript引擎在执行完同步代码之后，前往异步队列中获取任务执行，在执行完毕之后，再次前往异步队列中获取任务执行，以此循环往复，直到异步队列与主线程都空了为止。**

就这么简单。

仍然是以文章开头的例子说明。

```javascript    
    const log = str => console.log(str); 
    setTimeout(log,0,2);
    new Promise(()=>{
        log(3)
    })
    log(1); 
```

我们来分析一下它的执行过程。

1. 定义`log函数`
2. 向宏观任务队列中推入了`log(2)`
3. 向微观任务队列中推入了`log(3)`
4. 执行`log(1)`
5. 执行完毕，调用栈为空，任务队列不空，事件轮寻开启，查询任务队列，获取异步任务（微观任务优先）
6. 执行`log(3)`
7. 执行完毕，调用栈为空，任务队列不空，事件轮寻开启，查询任务队列，获取异步任务（微观任务优先）
8. 执行`log(2)`
9. 执行完毕，调用栈为空，任务队列为空，事件轮寻结束


# 总结

在你阅读完这片文章之后，你应该了解以下几个问题的答案。

> 什么是进程，线程
> 为什么会有进程，线程之分
> JavaScript同步与异步的执行机制
> 任务队列的划分
> event loop机制与执行过程



# 参考资料

[Help, I’m stuck in an event-loop.](https://vimeo.com/96425312)
[从event loop规范探究javaScript异步及浏览器更新渲染时机](https://github.com/aooy/blog/issues/5)
[JavaScript 运行机制详解：再谈Event Loop](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)
[线程与进程的关系](https://www.zhihu.com/question/25532384)